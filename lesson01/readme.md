# A. Partition


Базовым алгоритмом для быстрой сортировки является алгоритм partition, который разбивает набор элементов на две части относительно заданного предиката.
По сути элементы массива просто меняются местами так, что левее некоторой точки в нем после этой операции лежат элементы, удовлетворяющие заданному предикату, а справа — не удовлетворяющие ему.
Например, при сортировке можно использовать предикат «меньше опорного», что при оптимальном выборе опорного элемента может разбить массив на две примерно равные части.
Напишите алгоритм partition в качестве первого шага для написания быстрой сортировки.
## Формат ввода

В первой строке входного файла содержится число N — количество элементов массива (0 ≤ N ≤ 106).
Во второй строке содержатся N целых чисел ai, разделенных пробелами (-109 ≤ ai ≤ 109).
В третьей строке содержится опорный элемент x (-109 ≤ x ≤ 109).
Заметьте, что x не обязательно встречается среди ai.
## Формат вывода

Выведите результат работы вашего алгоритма при использовании предиката «меньше x»: в первой строке выведите число элементов массива, меньших x, а во второй — количество всех остальных.

### Пример 1
| Ввод      | 	Вывод |
|-----------|--------|
| 5         | 2      |
| 1 9 4 2 3 | 3      |
| 3         |        |

### Пример 2

| Ввод | 	Вывод |
|------|--------|
| 0    | 0      |
| -    | 0      |
| 0    |        |

### Пример 3

| Ввод | 	Вывод |
|------|--------|
| 1    | 0      |
| 0    | 1      |
| 0    |        |

### Примечания

Чтобы решить советуем реализовать функцию, которая принимает на вход предикат и пару итераторов, задающих массив (или массив и два индекса в нём), а возвращает точку разбиения, то есть итератор (индекс) на конец части, которая содержащит элементы, удовлетворяющие заданному предикату.
В таком виде вам будет удобно использовать эту функцию для реализации сортировки.

# B. Быстрая сортировка


Реализуйте быструю сортировку, используя алгоритм из предыдущей задачи.
На каждом шаге выбирайте опорный элемент и выполняйте partition относительно него. Затем рекурсивно запуститесь от двух частей, на которые разбился исходный массив.
## Формат ввода

В первой строке входного файла содержится число N — количество элементов массива (0 ≤ N ≤ 106).
Во второй строке содержатся N целых чисел ai, разделенных пробелами (-109 ≤ ai ≤ 109).
## Формат вывода

Выведите результат сортировки, то есть N целых чисел, разделенных пробелами.
### Пример 

| Ввод	     | Вывод     |
|-----------|-----------|
| 5         | 1 2 3 4 5 |
| 1 5 2 4 3 |           |

### Примечания

Используйте функцию, реализованную в предыдущей задаче.
# C. Слияние

Базовый алгоритм для сортировки слиянием — алгоритм слияния двух упорядоченных массивов в один упорядоченный массив. Эта операция выполняется за линейное время с линейным потреблением памяти. Реализуйте слияние двух массивов в качестве первого шага для написания сортировки слиянием.
## Формат ввода

В первой строке входного файла содержится число N — количество элементов первого массива (0 ≤ N ≤ 106).
Во второй строке содержатся N целых чисел ai, разделенных пробелами, отсортированные по неубыванию (-109 ≤ ai ≤ 109).
В третьей строке входного файла содержится число M — количество элементов второго массива (0 ≤ M ≤ 106).
В третьей строке содежатся M целых чисел bi, разделенных пробелами, отсортированные по неубыванию (-109 ≤ bi ≤ 109).
## Формат вывода

Выведите результат слияния этих двух массивов, то есть M + N целых чисел, разделенных пробелами, в порядке неубывания.
### Пример 1

| Ввод	     | Вывод           |
|-----------|-----------------|
| 5         | 1 2 3 5 5 5 6 9 |
| 1 3 5 5 9 |                 |
| 3         |                 |
| 2 5 6     |                 |

### Пример 2

| Ввод	 | Вывод |
|-------|-------|
| 1     | 0     |
| 0     |       |
| 0     |       |
| -     |       |

### Пример 3

| Ввод	 | Вывод |
|-------|-------|
| 0     | 0     |
| -     |       |
| 1     |       |
| 0     |       |

### Примечания

Для решения этой задачи советуем реализовать функцию, которая принимает на вход две пары итераторов, задающие два массива, и итератор на начало буфера, в который необходимо записывать результат. Итераторы можжно заменить на передачу массивов и индексов в них. В таком виде вам будет удобно использовать эту функцию для реализации сортировки.


# D. Сортировка слиянием

Реализуйте сортировку слиянием, используя алгоритм из предыдущей задачи.
На каждом шаге делите массив на две части, сортируйте их независимо и сливайте с помощью уже реализованной функции.
## Формат ввода

В первой строке входного файла содержится число N — количество элементов массива (0 ≤ N ≤ 106).
Во второй строке содержатся N целых чисел ai, разделенных пробелами (-109 ≤ ai ≤ 109).
## Формат вывода

Выведите результат сортировки, то есть N целых чисел, разделенных пробелами, в порядке неубывания.
### Пример

| Ввод	     | Вывод     |
|-----------|-----------|
| 5         | 1 2 3 4 5 |
| 1 5 2 4 3 |           |

### Примечания

Используйте функцию, реализованную в предыдущей задаче.

# E. Поразрядная сортировка

Поразрядная сортировка является одним из видов сортировки, которые работают практически за линейное от размера сортируемого массива время. Такая скорость достигается за счет того, что эта сортировка использует внутреннюю структуру сортируемых объектов. Изначально этот алгоритм использовался для сортировки перфокарт. Первая его компьютерная реализация была создана в университете MIT Гарольдом Сьюардом (Harold Н. Seward). Опишем алгоритм подробнее. Пусть задан массив строк s1 , ..., si причём все строки имеют одинаковую длину m. Работа алгоритма состоит из m фаз. На i -ой фазе строки сортируются па i -ой с конца букве. Происходит это следующим образом. Будем, для простоты, в этой задаче рассматривать строки из цифр от 0 до 9. Для каждой цифры создается «корзина» («bucket»), после чего строки si распределяются по «корзинам» в соответствии с i-ой цифрой с конца. Строки, у которых i-ая с конца цифра равна j попадают в j-ую корзину (например, строка 123 на первой фазе попадет в третью корзину, на второй — во вторую, на третьей — в первую). После этого элементы извлекаются из корзин в порядке увеличения номера корзины. Таким образом, после первой фазы строки отсортированы по последней цифре, после двух фаз — по двум последним, ..., после m фаз — по всем. При важно, чтобы элементы в корзинах сохраняли тот же порядок, что и в исходном массиве (до начала этой фазы). Например, если массив до первой фазы имеет вид: 111, 112, 211, 311, то элементы по корзинам распределятся следующим образом: в первой корзине будет. 111, 211, 311, а второй: 112. Напишите программу, детально показывающую работу этого алгоритма на заданном массиве.
## Формат ввода

Первая строка входного файла содержит целое число n (1 ≤ n ≤ 1000) . Последующие n строк содержат каждая по одной строке si . Длины всех si , одинаковы и не превосходят 20. Все si состоят только из цифр от 0 до 9.
## Формат вывода

В выходной файл выведите исходный массив строк в, состояние «корзин» после распределения элементов по ним для каждой фазы и отсортированный массив. Следуйте формату, приведенному в примере.

### Пример

| Ввод	                                                   | Вывод                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|---------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 9<br>12<br>32<br>45<br>67<br>98<br>29<br>61<br>35<br>09 | Initial array:<br> 12, 32, 45, 67, 98, 29, 61, 35, 09<br> **********<br> Phase 1<br> Bucket 0: empty<br> Bucket 1: 61<br> Bucket 2: 12, 32<br> Bucket 3: empty<br> Bucket 4: empty<br> Bucket 5: 45, 35<br> Bucket 6: empty<br> Bucket 7: 67<br> Bucket 8: 98<br> Bucket 9: 29, 09<br> **********<br> Phase 2<br> Bucket 0: 09<br> Bucket 1: 12<br> Bucket 2: 29<br> Bucket 3: 32, 35<br> Bucket 4: 45<br> Bucket 5: empty<br> Bucket 6: 61, 67<br> Bucket 7: empty<br> Bucket 8: empty<br> Bucket 9: 98<br> **********<br> Sorted array:<br> 09, 12, 29, 32, 35, 45, 61, 67, 98 |
